import { promises as fs } from "node:fs";
import path from "node:path";
import prettier from "prettier";
import assert from "node:assert/strict";

const projectRoot = process.cwd();
const contentRoot = path.join(projectRoot, "src/content");
const articlesRoot = path.join(contentRoot, "articles");
const manifestPath = path.join(contentRoot, "manifest.generated.ts");

function toPosix(p) {
  return p.split(path.sep).join("/");
}

function slugToId(slug) {
  return slug.replace(/[^a-zA-Z0-9]+/g, "_").replace(/^_+|_+$/g, "");
}

async function findMetaFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await findMetaFiles(fullPath)));
    } else if (entry.isFile() && entry.name === "meta.json") {
      files.push(fullPath);
    }
  }
  return files;
}

function formatArrayInline(items) {
  if (!Array.isArray(items) || items.length === 0) {
    return "[]";
  }
  return `[${items.map((item) => JSON.stringify(item)).join(", ")}]`;
}

function pushObject(lines, key, value, indent, suffix) {
  const json = JSON.stringify(value, null, 2);
  const jsonLines = json.split("\n");
  const pad = " ".repeat(indent);
  lines.push(`${pad}${key}: ${jsonLines[0]}`);
  for (let i = 1; i < jsonLines.length; i += 1) {
    lines.push(`${pad}${jsonLines[i]}`);
  }
  lines[lines.length - 1] = `${lines[lines.length - 1]}${suffix}`;
}

const metaFiles = await findMetaFiles(articlesRoot);
const entries = [];

for (const metaPath of metaFiles) {
  const raw = await fs.readFile(metaPath, "utf-8");
  const meta = JSON.parse(raw);

  assert(
    typeof meta.slug === "string" && meta.slug.length > 0,
    `${metaPath}: slug is required`,
  );
  assert(
    Array.isArray(meta.locales) && meta.locales.length > 0,
    `${metaPath}: locales must be a non-empty array`,
  );
  assert(
    typeof meta.createdAt === "string",
    `${metaPath}: createdAt must be a string`,
  );
  assert(
    typeof meta.updatedAt === "string",
    `${metaPath}: updatedAt must be a string`,
  );
  assert(
    typeof meta.title === "object" && meta.title,
    `${metaPath}: title must be an object`,
  );
  assert(
    typeof meta.summary === "object" && meta.summary,
    `${metaPath}: summary must be an object`,
  );
  assert(
    typeof meta.imageAlt === "object" && meta.imageAlt,
    `${metaPath}: imageAlt must be an object`,
  );
  assert(
    typeof meta.image === "string" && meta.image.length > 0,
    `${metaPath}: image must be a string`,
  );

  for (const locale of meta.locales) {
    assert(
      typeof meta.title[locale] === "string",
      `${metaPath}: title missing for locale ${locale}`,
    );
    assert(
      typeof meta.summary[locale] === "string",
      `${metaPath}: summary missing for locale ${locale}`,
    );
    assert(
      typeof meta.imageAlt[locale] === "string",
      `${metaPath}: imageAlt missing for locale ${locale}`,
    );
  }

  const articleDir = path.dirname(metaPath);
  const relDir = toPosix(path.relative(contentRoot, articleDir));
  const imagePath = `./${relDir}/assets/${meta.image}`;

  await fs.access(path.join(articleDir, "assets", meta.image));
  for (const locale of meta.locales) {
    await fs.access(path.join(articleDir, `${locale}.mdx`));
  }

  entries.push({
    id: slugToId(meta.slug),
    meta,
    relDir,
    imagePath,
  });
}

entries.sort((a, b) => a.meta.slug.localeCompare(b.meta.slug));

const lines = [];
lines.push(
  "// This file is generated by scripts/generate-content-manifest.mjs. Do not edit manually.",
);
lines.push('import type { Locale } from "@/modules/i18n/types";');
lines.push('import type { Category } from "@modules/category";');
lines.push('import type { ComponentType } from "react";');
lines.push('import type { StaticImageData } from "next/image";');

for (const entry of entries) {
  lines.push(`import image_${entry.id} from "${entry.imagePath}";`);
}

lines.push("");
lines.push("export type ContentEntry = {");
lines.push("  slug: string;");
lines.push("  locales: ReadonlyArray<Locale>;");
lines.push("  createdAt: string;");
lines.push("  updatedAt: string;");
lines.push("  category?: Category;");
lines.push("  tags?: string[];");
lines.push("  title: Record<Locale, string>;");
lines.push("  summary: Record<Locale, string>;");
lines.push("  imageAlt: Record<Locale, string>;");
lines.push("  image: StaticImageData;");
lines.push("  mdx: Record<Locale, () => Promise<{ default: ComponentType }>>;");
lines.push("};");
lines.push("");

for (const entry of entries) {
  const { meta, id, relDir } = entry;
  lines.push(`const entry_${id} = {`);
  lines.push(`  slug: ${JSON.stringify(meta.slug)},`);
  lines.push(`  locales: ${formatArrayInline(meta.locales)} as const,`);
  lines.push(`  createdAt: ${JSON.stringify(meta.createdAt)},`);
  lines.push(`  updatedAt: ${JSON.stringify(meta.updatedAt)},`);
  if (meta.category) {
    lines.push(`  category: ${JSON.stringify(meta.category)} as Category,`);
  }
  if (meta.tags) {
    lines.push(`  tags: ${formatArrayInline(meta.tags)},`);
  }
  pushObject(lines, "title", meta.title, 2, " as Record<Locale, string>,");
  pushObject(lines, "summary", meta.summary, 2, " as Record<Locale, string>,");
  pushObject(
    lines,
    "imageAlt",
    meta.imageAlt,
    2,
    " as Record<Locale, string>,",
  );
  lines.push(`  image: image_${id},`);
  lines.push("  mdx: {");
  for (const locale of meta.locales) {
    lines.push(`    ${locale}: () => import("./${relDir}/${locale}.mdx"),`);
  }
  lines.push("  },");
  lines.push("} satisfies ContentEntry;");
  lines.push("");
}

lines.push("export const contentEntries: ContentEntry[] = [");
for (const entry of entries) {
  lines.push(`  entry_${entry.id},`);
}
lines.push("];\n");

lines.push("export const contentBySlug: Record<string, ContentEntry> = {");
for (const entry of entries) {
  lines.push(`  [entry_${entry.id}.slug]: entry_${entry.id},`);
}
lines.push("};");
lines.push("");

const manifestContent = lines.join("\n");
const prettierConfig = (await prettier.resolveConfig(manifestPath)) ?? {};
const formatted = await prettier.format(manifestContent, {
  ...prettierConfig,
  filepath: manifestPath,
});

await fs.writeFile(manifestPath, formatted, "utf-8");
console.log(
  `Generated content manifest with ${entries.length} entries at ${manifestPath}`,
);
