import ArticleHeader from "@modules/article/ArticleHeader";
import ArticleImage from "@modules/article/ArticleImage";
import { authorList, authorName } from "@modules/metadata/constants";
import getArticleMetadata from "@modules/metadata/getArticleMetadata";
import { ArticleJsonLd } from "next-seo";
import cloudtype from "./cloudtype.png";
import {
  createdAt,
  image,
  item,
  summary,
  title,
  updatedAt,
  url,
} from "./metadata";
import i1 from "./time.avif";
import tsup_package from "./tsup_package.json.png";

export const metadata = getArticleMetadata(item);

<ArticleJsonLd
  useAppDir
  url={url}
  title={title}
  images={[image.src]}
  authorName={authorList}
  datePublished={createdAt}
  dateModified={updatedAt}
  publisherName={authorName}
  description={summary}
  type="BlogPosting"
  isAccessibleForFree
/>

<ArticleHeader title={title} updatedAt={updatedAt} desc={summary} />

<ArticleImage
  img={i1}
  alt="시간"
  caption={
    <>
      시간. Photo by{" "}
      <a href="https://unsplash.com/@aronvisuals?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">
        Aron Visuals
      </a>{" "}
      on{" "}
      <a href="https://unsplash.com/photos/selective-focus-photo-of-brown-and-blue-hourglass-on-stones-BXOXnQ26B7o?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">
        Unsplash
      </a>
    </>
  }
/>

## 개요

2023년 말에 간단한 포스기 앱을 만들었고, 그 경험을 에세이처럼 쓰는 글입니다. 그 예전에 썼던 글 (TODO: 링크 추가)과도 연결이 되어 있지요.

포스기란 결제/매출 시스템인 POS(Point Of Sale System)가 설치된 컴퓨터를 의미한다고 합니다. POS 는 완전히 영어인데 여기에 한국어인 "기"가 들어가니까 왠지 모를 친숙함이 느껴집니다. 마치 드라이기처럼요…

## 서막

2023년 후반에 참여했던 (지금은 거의 참여하지 않는… ㅠㅠ) 한 봉사단체가 있었습니다. 거기서는 활동비를 충당하기 위해서 회비를 받지 않는 대신 일년에 한 번 일일호프를 주최했습니다. 지인들을 초대하고 생긴 수익을 활동비로 썼죠. 일년에 한 번인 만큼 중요한 프로젝트였습니다. 주점을 통째로 빌리고 메뉴를 정하고 재료를 사고 정산도 하고 모두 직접 운영해야 하는 등 규모도 만만찮은 프로젝트.

공교롭게도 봉사단체에 개발자가 몇몇 있었습니다. 아이디어가 나왔습니다. 실제 운영할 때도 쓸 만한 포스기 앱을 만들자. 주문도 받고 주방에서도 편하고 정산할 때도 좋은 그런 앱! 이야기는 그렇게 시작되었고, 제가 합류한 시점은 완전 초반이었습니다. 딱히 결정된 게 없었어요. 다들 직장인이다 보니까 모여서 와글와글 프로젝트하는 20대의 파릇파릇한 느낌도 없었죠. 중요한 건 노력을 얼마나 들이지 않느냐 였습니다. 가장 적은 노력을 해서 가장 큰 효과를 봐야 하는 포스기 앱인 것이죠.

기술 스택은 일찌감치 결정되었습니다. 프론트는 Flutter, 백엔드는 Node.js.

정해진 것들이 크게 없다고 했었죠. 불확실한 것들을 안고 가도 어떻게든 되겠지 하는 아저씨스러운 마음이 있었습니다. 다들 개발 일 해왔고, ‘될 때엔 된다’는 건 모두 체득된 상태였죠... 이런 마음가짐이 재밌긴 합니다.ㅋㅋ 하여튼 당일 사용할 기기도 마땅히 정해질 기미가 보이지 않았습니다. 화면이 큰 태블릿 계열이긴 하겠지만 안드로이드 계열일 수도 있고 아이패드일 수도 있었어요. 빌드가 뜻대로 안되는 상황이 올 수도 있으니 그럴 땐 웹으로 또 급하게 돌려야 할 수도 있었습니다. 그래서 네이티브 개발은 애초부터 선택지에 없었고 남은 건 크로스 플랫폼 빌드를 할 수 있는 것. 2023년 시점에서 핫한 Flutter 와 React Native.

이 프레임워크가 각광받는 이유 중 하나는 높은 생산성입니다(진실이 아니더라도 저는 그렇게 믿고 있습니다). 특히 React Native 는 사실상 웹에서 많이 쓰이는 React 기반이라 개발자들이 이미 친숙하죠. Flutter 또한 빵빵한 구글이 팍팍 지원해주기도 하고 개발자들이 좋아하는 것들을 모아둔 느낌이었습니다. 크로스 플랫폼이라고 해서 거의 아무도 안쓰는 Qt를 사용할 것도 아니니깐… 뭘 사용해도 생산성이 적당히 나오겠다는 기대 + 어차피 React 란 회사에서도 많이 쓰는데, 이왕 새롭게 할 거 조금 공부하면서 쓰면 좋으니까 Flutter 로 가볍게 결정되었습니다.

백엔드도 필요하죠. Flutter 는 프론트니까 백을 뭘로 하지? 여기서는 그냥 익숙한 걸로 선택했습니다. Node.js. 프로젝트에 새로운 거 하나만 있으면 충분하죠.

전체 비율로 따지면… 음, 익숙한 것 7-80% 에 새롭게 배우는 것 2-30% 정도면 좋지 않을까 해요.

배포는 cloudtype 이라는 서비스를 이용하기로 했습니다. 2024년 시점에서는 돈을 착실히 내야 사용할 수 있는 서비스지만 2023년까지만 해도 베타 서비스라서 성능 좋은 DB 조차 공짜로(!) 쓸 수 있었어요. Vercel 처럼 배포 단위를 GitHub 리포지토리 단위로 가져갈 수 있었고 배포 명령어나 환경변수 등을 지정하기도 편했습니다.

<ArticleImage
  img={cloudtype}
  alt="cloudtype 배포 설정 화면"
  caption="cloudtype 배포 설정 화면"
/>

API 서버와 DB는 cloudtype 에 띄우고 Flutter 는 그냥 로컬 빌드하여 아이패드에 설치해서 보여주는 식으로 하기로 했습니다. 배포하는 게 전혀 복잡하지 않아서 Flutter 는 무조건 배포 서버를 바라보도록 했습니다. 아, DB나 그런건 테스트용과 운영용을 나누진 않았습니다. 심지어 DB Endpoint 도 그냥 리포지토리 프라이빗하게 해서 저장소에 다 때려박았습니다.

우리에게 중요한 건 **요구사항을 만족한 앱이 당일에만 안정적으로 잘 돌아가야 한다는 것** 밖에 없었으니까요. 보안은 중요하진 않았습니다. 지속적으로 운영될 것도 아니구요(운영과 개발이 동시에 이루어지지 않습니다)

## API 서버

팀의 분위기는 엄청 활발하진 않아서 저 혼자 상상의 나래를 펼쳐도 괜찮을 것 같아서 그렇게 했습니다. 다른 사람이 코드 읽었을 때 “이거 왜 이렇게 복잡해” 정도만 아니면 아무렴 괜찮지 않을까요? 그래서 야심차게 시도한 게 여럿 있습니다.

- [**tsup**](https://tsup.egoist.dev): esbuild 기반 번들링해주는 툴입니다. 개발 서버를 띄울 때 tsc 나 ts-node-dev 보다 훨씬 가볍고 쓰기도 편합니다. 또 전반적으로 쉬워서 간단하게 시작하기도 좋구요.
- [**prisma**](https://www.prisma.io/): Node.js 에서 유명한 ORM 라이브러리 입니다.
- [**itty-router**](https://github.com/kwhitley/itty-router): Express 보다 훨씬 가볍고 모던한 라우터입니다.
- [**async-mutex**](https://www.npmjs.com/package/async-mutex): 동시에 상태를 변경하는 요청이 여러 개 들어왔을 때 순차적으로 처리하기 위해 Mutex 를 활용했습니다.
- **vitest + 실제 DB 기반 테스트**
- **logtail + pino 로 로깅**

하나하나 좀 자세히 다뤄볼게요.

## Tsup

tsup 어떻게 읽어야 하죠? 티썹? 하여튼 이걸 처음 알게 된 계기는 [Turborepo의 Examples](https://github.com/vercel/turbo/tree/main/examples/kitchen-sink)를 들여다봤을 때였습니다. Turborepo란 모노레포와 관련된 툴이라 이 글과 관련은 전혀 없습니다. 거기에서 발견한 건 타입스크립트 기반 서버를 아주 간단하게 띄우는 코드였습니다.

아래는 [그 예시의 `package.json` 파일](https://github.com/vercel/turbo/blob/main/examples/kitchen-sink/apps/api/package.json)입니다.

<ArticleImage
  img={tsup_package}
  alt="Turborepo의 Example에 있었던 어떤 간단한 서버의 package.json 파일입니다."
  caption="Turborepo의 Example에 있었던 어떤 간단한 서버의 package.json 파일입니다."
/>

대충 `dev` , `build` , `start` 만 살펴보면 되겠습니다. `dev`란 개발 서버를 띄우기 위한 명령어이고, `build` 란 실제 production 환경에서 바로 사용할 수 있도록 타입스크립트 파일을 자바스크립트 파일로 적절하게 컴파일하는 명령어입니다. `start`란 빌드가 된 코드를 실행시키는 코드구요. 정말 간단하지 않나요? 사실상 `dev`는 `build`와 `start`를 합친 것과 같은 모양을 하고 있네요.

본래 번들링이란 브라우저에서 코드가 실행될 것이 가정되죠. 상황을 다양하게 고려해야 하고 과정도 복잡해서 webpack이나 vite의 설정은 결코 쉽지 않습니다. 반면 tsup의 번들링은 브라우저와 전혀 상관이 없습니다. 코드는 Node.js 에서만 잘 돌아가면 됩니다. 타입 체크야 간간히 `tsc` 를 직접 실행시켜 주면서 체크하면 됩니다. 타입 에러는 애초에 에디터에서 미리 알 수도 있구요.

아래는 Examples 에서 쓰인 tsup의 설정 파일입니다.

<CH.Code>

```ts tsup.config.ts
import { defineConfig, type Options } from "tsup";

export default defineConfig((options: Options) => ({
  entryPoints: ["src/index.ts"],
  clean: true,
  format: ["cjs"],
  ...options,
}));
```

</CH.Code>

그리고 아래는 실제로 쓰인 tsup 설정 파일입니다.

<CH.Code>

```ts tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/app.ts"],
  sourcemap: true,
  clean: true,
  target: "node18",
});
```

</CH.Code>

아주아주 간단해요. 너무 좋아요. 소스맵을 생성하는 것도 `sourcemap: true` 한 줄만 넣어주면 됩니다. `dev` 혹은 `start` 에서 `node` 명령어 실행할 때 중간에 `--enable-source-maps` 넣어주면 소스맵까지 읽어서 에러 메시지가 아주 읽기 편하게 된답니다. `dev` 명령어는 아래와 같습니다.

<CH.Code>

```
"dev": "tsup --config tsup.config.ts --watch --onSuccess \"node --enable-source-maps dist/app.js\"",
```

</CH.Code>

## prisma

프리즈마 굉장히 유명하죠. 핫합니다. 저도 함 써봤습니다. prisma는 기본적으로 아래 스키마 파일을 기반으로 DB가 막 바뀝니다. 직접 DDL을 만질 필요가 없다는 것이... 큰 장점일지는 모르겠지만 생산성 측면에서는 큰 이점입니다. 스키마만 잘 작성한 다음 `npx prisma migrate dev`만 실행시켜 주면 되기 때문이죠.

<CH.Code>

```prisma schema.prisma

/// 메뉴 테이블
model Menu {
  id             Int           @id @default(autoincrement())
  /// 메뉴명
  name           String        @db.VarChar(255)
  /// 설명
  description    String?
  /// 이미지 경로(상대경로)
  imageDir       String?
  /// 사용 가능 여부
  published      Boolean       @default(false)
  /// 가격
  price          Int           @default(0)
  /// 재고 갯수
  stock          Int           @default(0)
  /// 주문
  orders         Order[]
  /// 메뉴 카테고리
  MenuCategory   MenuCategory? @relation(fields: [menuCategoryId], references: [id])
  menuCategoryId Int?

  /// 판매량
  totalSalesCount Int? @default(0)
  /// 판매금액
  totalSalesPrice Int? @default(0)
}

/// 기타 등등... 이하 생략

```

</CH.Code>

DB 엔드포인트만 잘 설정한 다음에 스키마 설정하고 명령어 하나만 치면 그냥 막 테이블이 자기 알아서 잘 만들어진다는 소식을 듣고, 같이 하던 책임급 동료는 요즘 시대가 좋아졌다며 조용히 감탄하셨습니다. 나름 뿌듯?

마이그레이션도 뭐 편했습니다.

초반에 결정해야 할 사항들이 굉장히 많았는데

이를테면 제가 혼자서 고민했던 부분들은

## API 서버를 하면서 느낀 점

- 왠만하면 그냥 express 씁시다. 좀 투박한 느낌이긴 하지만 커뮤니티의 도움을 쉽게 받을 수 있다는 것이 무시못할 장점입니다. 문제에 부딪쳤을 때 해법이 아주 많으니까요.

아이디어는 굉장히 많았습니다. 테이블마다 URL 이 담겨있는 QR 코드를 붙여놓고, 이 쪽에서 주문하라고 하면 카운터와 주방의 화면에서 주문 목록이 갱신되며 모든 것이 맞물려 잘 돌아간다는 꿈을 그리기도 했습니다. 운영적으로 주문은 직접 받는 방향으로 결정되었습니다. 손님들이 직접 주문하는 화면 같은 건 필요가 없어졌죠.

다들 연차가 좀 있는 개발자였지만 앱 개발은 별로 해본 적이 없었습니다.

Flutter란 크로스 플랫폼(주로 iOS와 안드로이드) 앱을 만드는 프레임워크의 이름입니다. 구글에서 만들었죠. 이쪽 계열에서 흔히 라이벌로 React Native 가 많이 언급됩니다.

둘 중 어떤 걸 골라야 할까요? 사실 크게 고민하진 않았습니다.

포스기는 결제·매출 시스템인 POS(Point Of Sale System)가 설치된 터치형 PC를 말합니다.

Flutter 처음 해본 플러터.
